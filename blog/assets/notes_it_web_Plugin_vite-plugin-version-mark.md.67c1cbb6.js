import{_ as e,c as a,o,V as s}from"./chunks/framework.c277a2d0.js";const b=JSON.parse('{"title":"前端项目的版本标记","description":"","frontmatter":{},"headers":[],"relativePath":"notes/it/web/Plugin/vite-plugin-version-mark.md","filePath":"notes/it/web/Plugin/vite-plugin-version-mark.md","lastUpdated":1687742051000}'),n={name:"notes/it/web/Plugin/vite-plugin-version-mark.md"},l=s(`<h1 id="前端项目的版本标记" tabindex="-1">前端项目的版本标记 <a class="header-anchor" href="#前端项目的版本标记" aria-label="Permalink to &quot;前端项目的版本标记&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>低代码平台在给客户方部署新环境时，大概涉及如下内容：</p><ol><li><code>dev-webapp</code> - 低代码开发时（在这里搭建APP）</li><li><code>deploy-webapp</code> - 低代码运行时（搭建APP的运行环境）</li><li><code>admin-webapp</code> - 低代码管理平台（用来统一管理多个<em>deploy-webapp</em>）</li><li><code>appZip</code> - <em>dev-webapp</em> 搭建好的APP导出的zip包（在 <em>admin-webapp</em> 上传后，就可以在 <em>deploy-webapp</em> 里运行了）</li><li><code>service</code> - 后端服务</li></ol><p>上面涉及的内容里，前四项是与前端相关的。</p><p>我们需要确保每次给客户部署时，<code>dev-webapp</code>、<code>deploy-webapp</code>、<code>admin-webapp</code> 以及应用数据<code>appZip</code> 的版本一致，否则不一致的代码和数据混杂着，可想而知程序是大概率无法如期运行的。</p><p>运维人员在部署时拉取Docker镜像，可以通过镜像时间和 <code>tag</code> 来确定版本。但如果部署后项目运行遇到问题（或者很久后接到了帮客户修改一下bug的任务），这时候我们排查问题或修复bug，都需要或确定部署代码的版本、或找到当前版本的提交<code>checkout</code>修复问题。</p><p>这时如果在前端暴露一个 <code>id</code> 用来帮助前端人员快速定位问题/找到当时提交就很方便了。<code>git commit id</code> 似乎可以很好的完成这个任务。</p><h2 id="目的" tabindex="-1">目的 <a class="header-anchor" href="#目的" aria-label="Permalink to &quot;目的&quot;">​</a></h2><p>在项目打包时，把当前的 <code>git commit id</code> 混入到项目中，方便前端同学快速排查问题。</p><h2 id="代码" tabindex="-1">代码 <a class="header-anchor" href="#代码" aria-label="Permalink to &quot;代码&quot;">​</a></h2><p>github：<a href="https://github.com/ZhongxuYang/vite-plugin-version-mark" target="_blank" rel="noreferrer">vite-plugin-version-mark</a></p><p>npm：<a href="https://www.npmjs.com/package/vite-plugin-version-mark" target="_blank" rel="noreferrer">vite-plugin-version-mark</a></p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 获取当前分支最新commit hash</span></span>
<span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">rev-parse</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">HEAD</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 获取当前分支最新commit 短hash</span></span>
<span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">rev-parse</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--short</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">HEAD</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="todo" tabindex="-1">TODO <a class="header-anchor" href="#todo" aria-label="Permalink to &quot;TODO&quot;">​</a></h2><ul><li>与数据（应用包）的版本对应： <ul><li>在打包时，把版本记录在zip包内。在<code>admin-webapp</code>上传应用包可以查看版本号。</li><li>使用<code>commitID</code>作为版本唯一信息的话：如果在<code>dev</code>环境进行打包，在<code>demo</code>环境上传测试，那么<code>zip包</code>和<code>admin/deploy</code>的<code>commitID</code>是一定不一致的。如果要解决这个问题，就不能使用<code>commitID</code>作为版本号。</li></ul></li><li>与后端的版本对应</li></ul>`,16),i=[l];function p(t,c,r,d,m,h){return o(),a("div",null,i)}const g=e(n,[["render",p]]);export{b as __pageData,g as default};
