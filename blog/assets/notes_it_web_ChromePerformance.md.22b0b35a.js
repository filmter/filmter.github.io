import{_ as e,g as a,f as r,z as d}from"./app.2824fd48.js";const c="/blog/assets/record.5dd75f54.gif",o="/blog/assets/重复加载.1db61d9f.gif",t="/blog/assets/iShot.7d5b00fc.png",b=JSON.parse('{"title":"Chrome Performance","description":"","frontmatter":{},"headers":[{"level":2,"title":"问题描述","slug":"问题描述","link":"#问题描述","children":[]},{"level":2,"title":"问题分析","slug":"问题分析","link":"#问题分析","children":[{"level":3,"title":"排除接口耗时","slug":"排除接口耗时","link":"#排除接口耗时","children":[]},{"level":3,"title":"排查该问题时发现的另一个问题","slug":"排查该问题时发现的另一个问题","link":"#排查该问题时发现的另一个问题","children":[]}]},{"level":2,"title":"定位问题","slug":"定位问题","link":"#定位问题","children":[]}],"relativePath":"notes/it/web/ChromePerformance.md","lastUpdated":1678938501000}'),n={name:"notes/it/web/ChromePerformance.md"},s=d('<h1 id="chrome-performance" tabindex="-1">Chrome Performance <a class="header-anchor" href="#chrome-performance" aria-hidden="true">#</a></h1><h2 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-hidden="true">#</a></h2><p>在开发 <code>haida-webapp</code> 时，第一次加载 <code>luckysheet</code> 组件可以正常渲染，第二次加载浏览器会卡顿大概8秒才会有响应。 具体效果如下： <img src="'+c+'" alt="卡顿录屏" data-fancybox="gallery"></p><h2 id="问题分析" tabindex="-1">问题分析 <a class="header-anchor" href="#问题分析" aria-hidden="true">#</a></h2><h3 id="排除接口耗时" tabindex="-1">排除接口耗时 <a class="header-anchor" href="#排除接口耗时" aria-hidden="true">#</a></h3><p>根据录屏可看到，程序在进入新页面后，n个请求都在 <code>pending</code> 状态，但在接口成功请求后对应接口的耗时却都是毫秒级别。这里可以排除是接口耗时造成的。</p><h3 id="排查该问题时发现的另一个问题" tabindex="-1">排查该问题时发现的另一个问题 <a class="header-anchor" href="#排查该问题时发现的另一个问题" aria-hidden="true">#</a></h3><p>在排查本问题时，发现每次 <code>create</code> 组件都会往 <code>head</code> 中重复追加 <code>css</code> 以及 <code>js</code> 文件。如下图： <img src="'+o+'" alt="重复挂载" data-fancybox="gallery"></p><p>这样会造成多次加载重复的资源，调试发现是 <code>luckysheet</code> 在最新版本的源码中每次 <code>create</code> 都会追加文件，但并没有在 <code>destroy</code> 的时候移除这些无用文件。</p><p>这是一个修复项，但并不是此次浏览器卡顿的原因。</p><h2 id="定位问题" tabindex="-1">定位问题 <a class="header-anchor" href="#定位问题" aria-hidden="true">#</a></h2><p>怀疑项都没能得到确认后，通过 <code>Chrome Performance</code> 进行性能分析来排查原因。</p><p><img src="'+t+'" alt="" data-fancybox="gallery"></p><p>在上图中可以看到 <code>handleClearData</code> 方法耗时 <code>8.9s</code>，这显然是异常的，对应修复就可以啦。🎉</p>',14),i=[s];function l(h,p,_,f,m,g){return r(),a("div",null,i)}const x=e(n,[["render",l]]);export{b as __pageData,x as default};
