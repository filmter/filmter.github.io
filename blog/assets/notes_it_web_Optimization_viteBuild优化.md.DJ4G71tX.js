import{ac as e,h as i,f as a,aC as s}from"./chunks/framework.DoD2GAWc.js";const l="/blog/assets/compare.C5feq_pd.png",b=JSON.parse('{"title":"记录一次vite项目build优化过程","description":"","frontmatter":{},"headers":[],"relativePath":"notes/it/web/Optimization/viteBuild优化.md","filePath":"notes/it/web/Optimization/viteBuild优化.md","lastUpdated":1718610437000}'),t={name:"notes/it/web/Optimization/viteBuild优化.md"},n=s('<h1 id="记录一次vite项目build优化过程" tabindex="-1">记录一次vite项目build优化过程 <a class="header-anchor" href="#记录一次vite项目build优化过程" aria-label="Permalink to &quot;记录一次vite项目build优化过程&quot;">​</a></h1><h2 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-label="Permalink to &quot;问题描述&quot;">​</a></h2><p>在项目打包时，会报错 <code>out of memory</code> 然后终止运行。这个错误不是必现的。</p><p>按照 <code>vite</code> <a href="https://github.com/vitejs/vite/issues/2433" target="_blank" rel="noreferrer">issue</a> 中提到的方法，以前已经通过配置 <code>&quot;build&quot;: &quot;cross-env NODE_OPTIONS=--max-old-space-size=8192 vite build&quot;,</code> 临时避免了此问题，可这次再次出现。</p><h2 id="问题分析" tabindex="-1">问题分析 <a class="header-anchor" href="#问题分析" aria-label="Permalink to &quot;问题分析&quot;">​</a></h2><h3 id="表面原因" tabindex="-1">表面原因 <a class="header-anchor" href="#表面原因" aria-label="Permalink to &quot;表面原因&quot;">​</a></h3><p>为了正确定位原因，进行了多次打包测试。</p><p>主要是切换不同Node版本、主要依赖版本、代码版本（因为是本次合并后才出现的此问题）。</p><p>测试结果如下： <img src="'+l+`" alt="" data-fancybox="gallery" loading="lazy"></p><p>通过上面的表格可以发现，不包含 <code>@antv/g6</code> 包的代码 <code>build</code> 耗时更短。</p><p>虽然内存和耗时是两个概念，但仍能反应一些问题。</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>如果想要查看在 <code>build</code> 时的内存变化，这里提供两种方式：</p><ol><li><p>使用 <code>--inspect</code> 参数：</p><ul><li>例如：<code>&quot;build&quot;: &quot;node --inspect --max_old_space_size=16384 ./node_modules/vite/bin/vite.js build --mode deploy&quot;</code></li><li>浏览器进入 <code>chrome://inspect</code>，打开监控界面。</li></ul></li><li><p>使用 <code>pm2</code> 执行打包命令：</p><ul><li>使用 <code>pm2</code> 运行 <code>yarn build:test</code>： <ul><li><code>pm2 start yarn --name &quot;build&quot; --interpreter bash --no-autorestart -- run build</code></li><li>这将启动一个名为 <code>build</code> 的 <code>PM2</code> 进程，使用 <code>bash</code> 解释器来运行 <code>yarn</code> 命令，并在执行成功后退出。<code>--no-autorestart</code> 标志将防止进程在崩溃时自动重新启动。</li></ul></li><li>通过 <code>pm2 monit</code> 命令可以调出监控界面。</li></ul></li></ol></div><h3 id="根本原因" tabindex="-1">根本原因 <a class="header-anchor" href="#根本原因" aria-label="Permalink to &quot;根本原因&quot;">​</a></h3><p>造成 <code>vite build</code> 缓慢/内存消耗的根本原因在于项目中使用了 <code>@vitejs/plugin-legacy</code> 插件进行低版本浏览器的代码兼容造成的。</p><p>经过测试，同样的代码：</p><ul><li>在开启了该插件的情况下：打包耗时如上图在 <code>470s</code> 左右。</li><li>在关闭了该插件的情况下：打包耗时如上图在 <code>100s</code> 左右。</li></ul><p>可以看出差距是巨大的。</p><p>但是很明显对低版本浏览器的兼容是一项必须项。</p><h3 id="解决问题" tabindex="-1">解决问题 <a class="header-anchor" href="#解决问题" aria-label="Permalink to &quot;解决问题&quot;">​</a></h3><p>一开始的思路是通过配置 <code>vite.config</code> 的 <code>optimizeDeps.exclude</code> 来使 <code>vite</code> 不再分析 <code>@antv/g6</code>，经过测试发现并未生效。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><code>@vitejs/plugin-legacy</code> 会遍历项目中的所有 <code>JavaScript</code> 模块文件，将其中的 <code>ES6+</code> 语法转换为 <code>ES5</code> 语法，并将其输出到一个单独的文件中。因此，它不会关心 <code>optimizeDeps.exclude</code> 配置是否对某些文件生效。</p><p>如果你想避免 <code>@vitejs/plugin-legacy</code> 对某些模块进行编译：</p><ul><li><code>html</code> 中可以直接将这些模块标记为 <code>nomodule</code></li><li><code>import()</code> 动态导入的方式来加载该库</li></ul></div><p>在这里我们显然采用了动态加载的方式导入该库。修改的地方：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// *.vue</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initG6</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> G6</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@antv/g6&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(({</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    resolve: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        alias: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &#39;@antv/g6&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node_modules/@antv/g6/dist/g6.min.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>为了使用时的方便以及统一配置的好处，我们使用别名的方式引入 <code>node_modules/@antv/g6/dist/g6.min.js</code>。</p><p>尽管这样做解决了这个问题（节省服务器打包使用内存），因此也就要接受它的弊端，因为绕过了代码解析这一步骤也就缺少了对导入的模块进行代码处理（例如 TreeShake、Babel 转换、类型检查等）。</p><div class="warning custom-block"><p class="custom-block-title"><a href="https://caniuse.com/?search=import()" target="_blank" rel="noreferrer">import()兼容性</a></p><ul><li><code>Chrome</code> &gt;= 63</li><li><code>Edge</code> &gt;= 79</li><li><code>Safari</code> &gt;= 11.1</li><li><code>FireFox</code> &gt;= 67</li><li><code>Opera</code> &gt;= 50</li><li><code>IE</code> 不支持</li></ul></div><h3 id="其他思路" tabindex="-1">其他思路 <a class="header-anchor" href="#其他思路" aria-label="Permalink to &quot;其他思路&quot;">​</a></h3><p>类似的还有一些其他的解决方案，在这里记录下：</p><ul><li>同样的实现思路（都是避免vite编译），使用 <code>cdn</code> 加载，相应插件 <a href="https://github.com/MMF-FE/vite-plugin-cdn-import" target="_blank" rel="noreferrer">vite-plugin-cdn-import</a>。但这要求要在外网环境下使用。</li><li>本想写一个类似于 <a href="https://github.com/MMF-FE/vite-plugin-cdn-import" target="_blank" rel="noreferrer">vite-plugin-cdn-import</a> 的 <code>vite-plugin</code> 用于把引用的 <code>node_modules/*/lib/**</code> 转换为 <code>node_modules/*/dist/*.min.js</code>，后来醒悟这其实就是<a href="https://cn.vitejs.dev/config/shared-options.html#resolve-alias" target="_blank" rel="noreferrer">alias</a>提供的能力...</li></ul><h3 id="相关" tabindex="-1">相关 <a class="header-anchor" href="#相关" aria-label="Permalink to &quot;相关&quot;">​</a></h3><ul><li><a href="https://cn.vitejs.dev/config/dep-optimization-options.html#optimizedeps-exclude" target="_blank" rel="noreferrer">vite - optimizeDeps.exclude</a></li><li><a href="https://cn.vitejs.dev/guide/features.html#dynamic-import" target="_blank" rel="noreferrer">vite - 动态导入</a></li><li><a href="https://github.com/MMF-FE/vite-plugin-cdn-import" target="_blank" rel="noreferrer">vite-plugin-cdn-import</a></li><li><a href="https://caniuse.com/?search=import()" target="_blank" rel="noreferrer">import()兼容性</a></li></ul><h2 id="问题再次出现" tabindex="-1">问题再次出现 <a class="header-anchor" href="#问题再次出现" aria-label="Permalink to &quot;问题再次出现&quot;">​</a></h2><p>在稳定运行打包很久之后，运维把 <code>Jenkins</code> 升级重新部署了，再次出现此问题（怀疑是把Jenkins内存配置减少了，或者新版本Jenkins自身占用内存变多了，导致程序运行的可用内存减少）。</p><hr><p>通过Rollup官网可以看到，之所以会报错 <code>JavaScript heap out of memory</code>，其主要原因如 <a href="https://rollupjs.org/troubleshooting/#error-javascript-heap-out-of-memory" target="_blank" rel="noreferrer">Rollup - Error: JavaScript heap out of memory</a> 所说：</p><p>由于 <code>Rollup</code> 需要同时将所有模块信息保存在内存中，以便分析除屑优化（<code>Tree-Shaking</code>）的相关副作用，因此打包大型项目可能会达到 <code>Node</code> 的内存限制。</p><p>官网也给出了解决方案：</p><ol><li>按需增加 <code>--max-old-space-size</code> 。请注意，这个数字可以安全地超过你的可用物理内存。在这种情况下，Node 会根据需要将内存分页到磁盘上。</li><li>你可以通过使用动态导入引入代码分割、只导入特定的模块而不是整个依赖、禁用 <code>sourcemap</code>，或者增加交换空间的大小来减少内存压力。</li></ol><h2 id="循环依赖" tabindex="-1">循环依赖 <a class="header-anchor" href="#循环依赖" aria-label="Permalink to &quot;循环依赖&quot;">​</a></h2><p>使用新版本 <code>vite</code> 构建时会报警告信息（其实是上游 <code>Rollup</code> 发出的警告）:</p><div class="warning custom-block"><p class="custom-block-title">警告信息</p><p>while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.</p></div><p>即：代码中的 <code>modules</code> 存在循环依赖，目前还不能很好的支持这种情况。</p><p>本以为内存溢出或许和这里有关系，在修改了800多个文件去除了所有的循环引用后测试，内存依然溢出。</p><p>虽然没有解决此问题，但是在开发时代码运行貌似有所提升，而且偶现的 <code>Unexpected error when starting the router: ReferenceError: Cannot access &#39;***&#39; before initialization</code> 也不再出现（相关：<a href="https://github.com/vitejs/vite/issues/4430#issuecomment-979013114" target="_blank" rel="noreferrer">you can&#39;t eagerly access imported bindings of a file that&#39;s later in the import chain</a>）。</p><h2 id="排查在build的哪一阶段内存飙升" tabindex="-1">排查在build的哪一阶段内存飙升 <a class="header-anchor" href="#排查在build的哪一阶段内存飙升" aria-label="Permalink to &quot;排查在build的哪一阶段内存飙升&quot;">​</a></h2><ul><li>我们可以通过<a href="https://cn.rollupjs.org/plugin-development/#augmentchunkhash" target="_blank" rel="noreferrer">rollup的钩子</a>，逐个排查在哪一阶段内存开始飙升的。</li><li>观测钩子log和内存监视器。定位内存消耗在哪一阶段。</li><li>但有些时候钩子函数并不足够细致可以让我们排查问题，这时候把 <code>rollup</code> 源代码 <code>clone</code> 到本地使用 <code>npm link</code>，在本地源码调试。</li></ul><h2 id="暂时的解决方案" tabindex="-1">暂时的解决方案 <a class="header-anchor" href="#暂时的解决方案" aria-label="Permalink to &quot;暂时的解决方案&quot;">​</a></h2><p>把配置中的 <code>&quot;build&quot;: &quot;node --max_old_space_size=16384 ./node_modules/vite/bin/vite.js build --mode dev&quot;</code> 的 <code>max_old_space_size=16384</code> 改为 <code>8192</code> 解决了 <code>jenkins</code> 中 <code>kill</code> 进程。</p><p>据运维说是 <code>jenkins</code> 一共分配了 <code>16g</code> ，而运行这一个程序就请求 <code>16g</code> 空间，因此才会被kill。</p><p>这样改过之后依然偶有 <code>build killed</code>，还是要从官网建议的代码优化方面入手。之后有时间再尝试整理。</p>`,50),o=[n];function d(r,p,c,h,u,k){return a(),i("div",null,o)}const g=e(t,[["render",d]]);export{b as __pageData,g as default};
